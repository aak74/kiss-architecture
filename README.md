# KISS Architecture

## Предпосылки
Нам как разработчикам все время рассказывают об итеративном подходе к разработке. Например часто можно услышать о принципах YAGNI и KISS. Но этот подход пропагандируют для уровня реализации приложений.

А что если применить подход KISS и YAGNI к архитектурному уровню?
Я и название придумал KISS Architecture, потому как YAGNI Architecture звучит еще более неоднозначно :) 


## Выбор жертвы
Существует масса подходов к проектированию архитектуры приложения. Это и MVC, DDD, Clean Architecture, Hexagonal Architecture и множество других. 

MVC хорошо подходит для маленьких приложений. При попытке масштабирования такая архитектура превращается в самую распространенную архитектуру в мире IT - Большой ком грязи.

DDD отличная архитектура, но ее никто не понимает. Ну разве что сам создатель и пара архитекторов. Цель же архитектуры состоит в том, чтобы она было понятна каждому разработчику.

Clean Architecture отличная архитектура, но ее полная реализация имеет смысл для огромных приложений. Для малых и средних приложений она показалась мне слишком сложной. При современных тенденциях перехода от монолита к сервисам и микросервисам  эта архитектура становится слишком тяжеловесной.

Hexagonal Architecture самая недооцененная архитектура изо всех мне известных. Но и эта архитектура достаточно сложна для большинства приложений. И вот эту архитектуру мы и возьмем для упрощения.

Описание Hexagonal Architecture она же Ports and Adapters Architecture выходит за пределы данного документа. На просторах Интернета несложно найти ее описание.

## Ингредиенты
Правильная архитектура состоит из слоев
Вот ингредиенты, из которых нам предстоит собрать KISS Architecture:
- Routers
- Controllers
- Views
- Services
- Models

### Router
Router присутствует в любой архитектуре, но часто в неявном виде. А поскольку явное всегда лучше неявного, то стоит его вытащить наружу.

Router отвечает за маршрутизацию запросов. Router является верхнеуровневым квантом нашей архитектуры. Размер роутера и их количество косвенно говорит о размере приложения. Для большого монолитного приложения **может быть более одного слоя роутеров**.

### Controller
Контроллер является прослойкой между роутером и сервисами. Бизнес логики в контроллере быть не должно.

Каждый контроллер управляет только одной сущностью. Если нужно больше сущностей, то нужно добавить еще один контроллер. Контроллер является еще одним квантом нашей архитектуры. Количество и размер контроллеров косвенно говорит о размере приложения. Вертикальный слой под контроллером можно выделить в отдельный микросервис.


### View
View находится в одном слое с контроллером. Контроллер после получения данных из сервиса передает данные во View и возвращает View для отображения. Бизнес логики во View быть не должно.

В предельном случае View представляет собой JSON, XML и подобные форматы.

### Service
Только Сервис может содержать бизнес логику. Сервис обычно обращается только к одной модели. Сервис может вызвать другой сервис.

Слой сервисов разделяем на Commands и Queries. Это стандартный подход для CQRS.

Один сервис выполняет только одну функцию. Приватных функций может быть сколько угодно, а публичная только одна. Название сервиса должно начинаться с глагола. Примеры: GetUsers, GetPostById, UpdateUser, PublishPost. Именно название сервиса намекает на правильное разделение функционала.

В Queries помещаем сервисы, которые не изменяют БД. Содержит одну публичную функцию get.

В Commands помещаем сервисы, которые изменяют БД. Содержит одну публичную функцию execute.

### Models
Модель содержит только простейшую логику связанную с чтением и сохранением данных. Причем эти манипуляции могут быть и не связаны с БД. Например, модель может обращаться к HTTP серверу.

Если модель работает с БД, то одна модель может обслуживать более одной таблицы.

## Рецепты
### Микросервис
Микросервис в моем понимании должен управлять только одной сущностью. Поэтому архитектура для простейшего микросервиса будет выглядеть таким образом:
Один Роутер, один Контроллер, несколько Views, несколько Сервисов, одна Модель.

### Сервис
Сервис - это мини приложение, в котором фигурирует несколько сущностей. Это приложение содержит:
Один Роутер, несколько Контроллеров, несколько Views, несколько Сервисов несколько Моделей.

### Монолит
Монолит - это большое приложение, в котором фигурирует много сущностей. Монолиты никто не любит по причине их монструозности. Монолит может быть оправдан если следовать подходу Monolith first. В таком состоянии ваше приложение может пребывать довольно долго.

Монолит содержит в себе:
один СуперРоутер, несколько обычных Роутеров, много Контроллеров, много Views, много Сервисов и много Моделей.

Начинает это выглядеть немного страшно. Для сохранения стройности архитектуры был добавлен верхнеуровневый роутер, который будет разруливать глобальные пути. Кроме этого нужно распределить файлы в структуре помодульно. То есть в соответствии с будущим распилом на отдельные сервисы.

При правильном разделении на модули позволяет оставаться приложению управляемым и поддерживаемым. Распиливание монолита на части становится чисто механической задачей.

## Тестирование
В рамках рассматриваемой архитектуры тщательному тестированию подлежат только сервисы. А мокать нужно только Модели.

Если у вас возникает желание протестировать, что-то кроме сервисов, то вероятно место для логики выбрано неправильно.

## Заключение
На мой взгляд KISS Architecture подходит для 80% проектов. Может обеспечить плавную эволюцию вашего проекта.

При развитии вашего приложения в виде монолита возможно вам не хватит KISS Architecture. Тогда из этой архитектуры вы можете плавно мигрировать в Hexagonal Architecture она же Ports and Adapters Architecture.

KISS Architecture будет понятна всем разработчикам и для его использования не нужно читать толстенные книги про DDD или Clean Architecture.
